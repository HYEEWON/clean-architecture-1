# 5. 웹 어댑터 구현하기

## 목차
* [의존성 역전](#의존성-역전)
* [웹 어댑터의 책임](#웹-어댑터의-책임)
* [컨트롤러 나누기](#컨트롤러-나누기)

<br>

## 의존성 역전

<img src="https://github.com/HYEEWON/clean-architecture-1/assets/38900338/0b572518-90c8-438b-8ea7-e15890657385" height="120px">

* 웹 어댑터: `인커밍` 그리고 `주도하는` 어댑터
  * 외부에서 요청을 받아 애플리케이션 코어를 호출하고 무슨 일을 해야 할지 알려줌
  * 제어 흐름: 웹 어댑터에서 서비스로 향함
* 애플리케이션 계층은 웹 어댑터가 통신에 사용할 수 있는 `포트`를 제공
  * 서비스는 포트를 구현 -> 웹 어댑터는 포트를 호출
  * `의존성 역전 원칙`이 적용됨
* 포트가 필요한 이유
  * 포트: 애플리케이션 코어가 외부와 통신할 수 있는 곳에 대한 명세
  * 외부와 어떤 통신이 일어나고 있는지 파악할 수 있음, 유지보수에 좋음

<br>

## 웹 어댑터의 책임

* HTTP와 관련된 것은 애플리케이션 계층으로 침투하면 안됨
* 도메인 로직을 수행하지 않음
* 웹 어댑터와 애플리케이션 계층 간의 경계는 `도메인과 애플리케이션 계층부터 개발`하기 시작하면 자연스럽게 생김 (`유스케이스 먼저 구현`)

```
1. HTTP 요청을 자바 객체로 매핑
2. 권한 검사
3. 입력 유효성 검증
4. 입력을 유스케이스의 입력 모델로 매핑
5. 유스케이스 호출
6. 유스케이스의 출력을 HTTP로 매핑
7. HTTP 응답 반환
```

* 1: HTTP 요청 수신, 요청 파라미터와 콘텐츠를 객체로 직렬화
* 2: 인증과 권한 부여 수행, 에러 발생
* 3: `웹 어댑터의 입력 모델은 유스케이스의 입력 모델과 다를 수 있어 유효성 검사 필요`
  * 웹 어댑터의 입력 모델을 유스케이스의 입력 모델로 변환할 수 있는지 검증
* 4: 웹 어댑터의 입력 모델을 유스케이스의 입력 모델로 매핑
* 5: 변환된 입력 모델로 유스케이스 호출
* 6: 유스케이스의 출력을 받아 HTTP 응답으로 직렬화
* 7: 호출자에게 전달

<br>

## 컨트롤러 나누기

* 각 컨트롤러는 가능한 좁고, 다른 컨트롤러와 가능한 적게 공유하도록 함
  * 모델을 공유하지 않는 여러 작은 클래스를 만들어야 함
* 각 연산에 대해 별도의 패키지 안에 별도의 컨트롤러를 만드는 것이 좋음
* 메서드와 클래스명은 유스케이스를 최대한 반영

#### 👎 하나의 컨트롤러에 모든 기능이 있다면..
* 컨트롤러 및 테스트 `코드 파악이 어려워짐`
  * 클래스는 코드가 적을수록 좋음
* 모든 연산을 단일 컨트롤러에 넣는 것은 `데이터 구조의 재활용을 촉진`함

#### 👍 나누는 스타일의 장점.. 
* 전용 모델 사용 -> 컨트롤러의 패키지에 대해 `private`으로 선언 -> 재사용 실수 감소
* 서로 다른 연산에 대한 `동시 작업`이 쉬워짐
