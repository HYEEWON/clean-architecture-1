# 아키텍처 경계 강제하기

## 목차
* [경계와 의존성](#경계와-의존성)
* [접근 제한자](#접근-제한자)
* [컴파일 후 체크](#컴파일-후-체크)
* [빌드 아티팩트](#빌드-아티팩트)

<br>

## 경계와 의존성

* `경계를 강제함`: `의존성`이 올바른 방향을 향하도록 강제함
* 가장 안쪽에는 도메인 엔티티가 있음
* 경계를 넘는 의존성은 항상 안쪽을 향함

<br>

## 접근 제한자

* `public`, `private`, `protected`, `default(package-private)`가 있음

```
app
└── account
    ├── adapter
    │   ├── in
    │   │   └── web
    │   │       └── O AccountController
    │   └── out
    │       └── persistence
    │           ├── O AccountPersistenceAdapter
    │           └── O SpringDataAccountRepository
    ├── application
    │   ├── O SendMoneyService
    │   └── port
    │       ├── in
    │       │   └── + SendMoneyUseCase
    │       └── out
    │           ├── + LoadAccountPort
    │           └── + UpdateAccountStatePort
    └── domain
        ├── + Account
        └── + Activity
```

```
-: private
+: public
#: protected
O: default
```

* `default`를 사용하고 모듈의 진입점으로 활용될 클래스만 `public`으로 하면 잘못된 의존성을 가질 위험을 줄일 수 있음
  * `adapter`, `service`: default 가능
  * 그 외: public
* 패키지에 클래스 수가 증가하면 코드를 쉽게 찾을 수 있도록 하위 패키지를 만들 수 있음
  * 자바에서 하위 패키지는 다른 패키지로 취급 -> default로 할 경우, 접근이 불가해 의존성 규칙이 깨지는 문제가 발생할 수 있음

<br>

## 컴파일 후 체크

* 컴파일러는 의존성 규칙을 위반했는지 확인할 수 없음 -> 컴파일 후 체크 방법 도입
* 컴파일 후 체크: 코드가 컴파일된 후에 `런타임`에 체크
  * ex. archUnit (의존성 방향을 확인하는 API 제공)

#### 👎 단점
* 실패에 안전(fail-safe)하지 않음 (오타, 패키지명 변경 등) -> `항상 코드와 함께 유지보수해야 함`

<br>

## 빌드 아티팩트

* 빌드 아티팩트: 빌드 프로세스의 결과물
* 빌드 도구: maven, gradle
* 빌드 도구의 기능 중 하나는 `의존성 해결`
  * 빌드 도구는 코드베이스가 의존하고 있는 모든 아티팩트가 사용 가능한지 확인 -> 사용 불가라면 컴파일 전에 에러 발생, 빌드 실패
  * 이 기능으로 계층 간의 의존성을 강제할 수 있음
* 각 모듈의 빌드 스크립트에서는 아키텍처에서 허용하는 의존성만 지정 -> `컴파일 에러`가 발생하기 때문에 human fault 방지 가능
* ⭐ 아키텍처를 여러 빌드 아티팩트로 나누는 것이 좋음

<img src="https://github.com/HYEEWON/clean-architecture-1/assets/38900338/a1b07b23-c25e-4cd5-bf40-e570ca3cd8b7" height="550px">

* 어댑터 모듈: 웹 어댑터 + 영속성 어댑터 -> 격리하는 것이 좋음 (단일 책임 원칙)
* 애플리케이션 모듈
  * 도메인 엔티티가 포트에서 전송 객체로 사용되지 않는 경우(매핑하지 않기 전략을 사용하지 않는 경우)에 분리할 수 있음
  * 인커밍 포트와 아웃고잉 포트 모듈로 분리
  * 서비스와 도메인 엔티티 모듈로 분리 -> 엔티티가 서비스에 접근할 수 없게 됨

#### 👍 장점
* 모듈을 세분화할수록 의존성을 잘 제어할 수 있게 됨

#### 👎 단점
* 작게 분리할수록 모듈간 매핑이 많아져야 함

#### 👍 빌드 모듈로 경계를 구분하는 것의 장점 (패키지로 구분하는 것과 비교)
* 순환 의존성을 막을 수 있음
* 다른 모듈을 고려하지 않고, 특정 모듈의 코드를 격리한 채로 변경 가능
* 모듈 간 의존성이 빌드 스크립트에 선언되어 있어 의식적으로 새로운 의존성을 추가해야 함
